# Graph Problems

This repository contains solutions to various graph problems categorized by difficulty level. These problems are designed to enhance your understanding of graph algorithms and data structures.

## Easy

1. **[Number of Islands](#)**  
   Count the number of islands in a 2D grid.

2. **[Flood Fill](#)**  
   Implement a flood fill algorithm.

3. **[Clone Graph](#)**  
   Clone a graph with N nodes and M edges.

4. **[Course Schedule](#)**  
   Determine if you can finish all courses given prerequisites.

5. **[Graph Valid Tree](#)**  
   Check if a given graph is a valid tree.

6. **[Is Graph Bipartite?](#)**  
   Check if a graph can be colored using two colors.

7. **[Minimum Depth of Binary Tree](#)**  
   Find the minimum depth of a binary tree.

8. **[Binary Tree Level Order Traversal II](#)**  
   Perform level order traversal of a binary tree in reverse.

## Medium

1. **[Course Schedule II](#)**  
   Return the order of courses to finish given prerequisites.

2. **[Word Ladder](#)**  
   Transform a word to another word using a given dictionary.

3. **[Number of Connected Components in an Undirected Graph](#)**  
   Find the number of connected components in an undirected graph.

4. **[Redundant Connection](#)**  
   Find the redundant connection in a graph.

5. **[Shortest Path in Binary Matrix](#)**  
   Find the shortest path in a binary matrix from the top-left to the bottom-right corner.

6. **[Longest Increasing Path in a Matrix](#)**  
   Find the length of the longest increasing path in a matrix.

7. **[Network Delay Time](#)**  
   Find the time it takes for all nodes to receive a signal in a network.

8. **[Find Eventual Safe States](#)**  
   Find all nodes that are guaranteed to be safe in a directed graph.

9. **[Number of Distinct Islands](#)**  
   Count the number of distinct islands in a 2D grid.

10. **[All Paths from Source to Target](#)**  
    Find all paths from source to target in a directed acyclic graph (DAG).

11. **[Minimum Cost to Hire K Workers](#)**  
    Find the minimum cost to hire K workers from different teams.

12. **[Reachable Nodes In Subdivided Graph](#)**  
    Determine the number of reachable nodes in a subdivided graph.

13. **[Find the Shortest Path in an Unweighted Graph](#)**  
    Use Breadth-First Search to find the shortest path.

14. **[Cycle Detection in a Directed Graph](#)**  
    Detect a cycle in a directed graph.

15. **[Minimum Spanning Tree](#)**  
    Implement algorithms like Kruskal’s or Prim’s to find the minimum spanning tree.

## Hard

1. **[Dijkstra's Algorithm](#)**  
   Find the shortest paths from a source to all other vertices in a weighted graph.

2. **[Traveling Salesman Problem](#)**  
   Solve the Traveling Salesman Problem using exact or approximate methods.

3. **[Network Flow](#)**  
   Implement algorithms for network flow problems like the Ford-Fulkerson method.

4. **[Bellman-Ford Algorithm](#)**  
   Find the shortest path from a source vertex to all other vertices in a graph that may contain negative weights.

5. **[Floyd-Warshall Algorithm](#)**  
   Find shortest paths between all pairs of vertices in a weighted graph.

6. **[Topological Sort](#)**  
   Perform topological sorting on a directed acyclic graph (DAG).

7. **[Strongly Connected Components](#)**  
   Find all strongly connected components in a directed graph using Kosaraju’s or Tarjan’s algorithm.

8. **[Hamiltonian Path](#)**  
   Determine if there exists a Hamiltonian path in a graph.

9. **[Graph Coloring](#)**  
   Determine if a graph can be colored with k colors such that no two adjacent vertices have the same color.

10. **[Maximum Flow Problem](#)**  
    Compute the maximum flow from a source to a sink in a network.

## Contributing

Feel free to contribute by adding solutions to the problems or improving existing ones. Fork the repository, make your changes, and submit a pull request.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Acknowledgements

Thanks to the algorithm and coding communities for providing these problems and solutions. Special thanks to [LeetCode](https://leetcode.com), [HackerRank](https://hackerrank.com), and [GeeksforGeeks](https://geeksforgeeks.org) for their excellent problem sets.

